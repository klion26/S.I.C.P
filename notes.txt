1. Building Abstractions with Procedures  
	1.1 The Elements of Programming  
		Every powerful language has three mechanisms for accomplishing this:  
			a. **primitive expressions**, which represent the simplest entities the language is concerned with,  
			b. **means of combination**, by which compound elements are built from simpler ones, and  
			c. **means of abstraction**, by which compound elements can be named and manipulated as units.
		Two kinds of elements in programming:    
			a. procedures
			b. data.  
		
		1.1.1 Expressions  
			prefix natation advantages:  
				a. take an arbitrary number of arguments
				b. it extends in a straight forward way to allow combinations to be nested.  
		1.1.2 Naming and the Environment  
		1.1.3 Evaluating Combinations
		1.1.4 Compound Procedures
		1.1.5 The Substitution Model for Procedure Application
		1.1.6 Conditional Expressions and Predicates
		1.1.7 Example: Square Roots by Newton's Method
		1.1.8 Procedures as Black-Box Abstractions
	1.2 Procedures and the Processes They Generate  
		1.2.1 Linear Recursion and Iteration
		1.2.2 Tree Recursion  : Fibonacci numbers
		1.2.3 Orders of Growth
		1.2.4 Exponentiation : a^b
			How to change the algorithm of b^n from recurisuve to iterative?
				1. set a*b^i as a state, and, keep the state in state
				2. update i, b and a
					2.a if i is odd, a=a*b i=i-1
					2.b else b=b^2, i=i/2
		1.2.5 Greatest Common Divisors  
			Euclid's Algorithm
			Lame's Theorem
		1.2.6 Example: Testing for Primality
	1.3 Formulating Abstractions with Higher-Order Procedures
		Procedures that manipulate procedures are called **higer-order procedures**.
		1.3.1 Procedures as Arguments : Abstraction
			{sum, product} => accumulate => filtered-accumulate
		1.3.2 Constructing Procedures Using Lambda
