1. Building Abstractions with Procedures  
	1.1 The Elements of Programming  
		Every powerful language has three mechanisms for accomplishing this:  
			a. **primitive expressions**, which represent the simplest entities the language is concerned with,  
			b. **means of combination**, by which compound elements are built from simpler ones, and  
			c. **means of abstraction**, by which compound elements can be named and manipulated as units.
		Two kinds of elements in programming:    
			a. procedures
			b. data.  
		
		1.1.1 Expressions  
			prefix natation advantages:  
				a. take an arbitrary number of arguments
				b. it extends in a straight forward way to allow combinations to be nested.  
		1.1.2 Naming and the Environment  
		1.1.3 Evaluating Combinations
		1.1.4 Compound Procedures
		1.1.5 The Substitution Model for Procedure Application
		1.1.6 Conditional Expressions and Predicates
		1.1.7 Example: Square Roots by Newton's Method
		1.1.8 Procedures as Black-Box Abstractions
	1.2 Procedures and the Processes They Generate  
		1.2.1 Linear Recursion and Iteration
		1.2.2 Tree Recursion  : Fibonacci numbers
		1.2.3 Orders of Growth
		1.2.4 Exponentiation : a^b
			How to change the algorithm of b^n from recurisuve to iterative?
				1. set a*b^i as a state, and, keep the state in state
				2. update i, b and a
					2.a if i is odd, a=a*b i=i-1
					2.b else b=b^2, i=i/2
		1.2.5 Greatest Common Divisors  
			Euclid's Algorithm
			Lame's Theorem
		1.2.6 Example: Testing for Primality
	1.3 Formulating Abstractions with Higher-Order Procedures
		Procedures that manipulate procedures are called **higer-order procedures**.
		1.3.1 Procedures as Arguments : Abstraction
			{sum, product} => accumulate => filtered-accumulate
		1.3.2 Constructing Procedures Using Lambda
			lambda is used to create procedures in the same way as define, except that no name is specified for the procedure
			using let to create local variables(let is a syntactic sugar of lambda)
				(let ((<var1> <exp1>) (<var2> <exp2>) ... (<varn> <expn>)) <body>), The variables' values are computed outside the let.
				(let ((x 3) (y (+ x 2))) (* x y)), if x==2, then, y=4(= 2+2)
		1.3.3 Procedures as General Methods: zeros and fixed points of functions
			k-term finite continued fraction => golden ratio, natural logarithms, tan(x)
		1.3.4 Procedures as Returned Values
2. Building Abstractions with Data
	2.1 Introduction to Data Abstraction
		2.1.1 Example: Arithmetic Operations for Rational Numbers
			pairs: (define x (cons 1 2)) (car x)=>1 (cdr x)=>2, cons can be used to form pairs whose elements are pairs.
		2.1.2 Abstraction Barriers
			Any complex data structure can be represented in a variety of ways with the primitive data structures provided by a programming language.
		2.1.3 What Is Meant by Data?
			Any triple of procedures that satisfies "if z is (cons x y) then (car z) is x and (cdr z) is y" can be used as the basis for implementing pairs.
	2.2 Hierarchical Data and the Closure Property
		2.2.1 Representing Sequences
			List: (cons a1 (cons a2 (cons a3 (cons ... (cons an nil))))).
			(list-ref listname n) return the nth(0-based) element
		2.2.2 Hierarchical Structures
